import motor
import motor_pair
import runloop
from hub import motion_sensor, port
import utime
import color_sensor
import hub

print("Battery Voltage:",hub.battery_voltage())
print("Battery Current:",hub.battery_current())
print("Battery Temp:",hub.battery_temperature())

SOL_TEKER = port.A
SAG_TEKER = port.B
KALDIRAC = port.E
DERIVATIVE = port.D
RENK = port.F



class Device:
    def __init__(self, device_type, device_name, *args):
        self.device_type = device_type
        self.device_name = device_name
        self.args = args


    def __repr__(self):
        return f"Device(type={self.device_type}, name={self.device_name}, args={self.args})"

class Servo(Device):
    def get_angle(self, timeout=1):
        return input(f";devices.{self.device_name}.get_angle();\n")
    def set_angle(self, angle, timeout=2):
        print("yapyom:",angle)
        return input(f";devices.{self.device_name}.set_angle({angle});\n")

class DistanceSensor(Device):
    def get_distance(self, timeout=1):
        return input(f";devices.{self.device_name}.get_distance();\n")

class Raspi:
    def register_device(self, device_type, device_name, *args, timeout=1):
        input(f";devices.register({device_type}, {device_name}, {', '.join(args)});\n")
        if device_type == "servo":
            return Servo(device_type, device_name, *args)
        elif device_type == "distance_sensor":
            return DistanceSensor(device_type, device_name, *args)
        else:
            raise ValueError(f"Unsupported device type: {device_type}")




def getGyro():
    return -1*motion_sensor.tilt_angles()[0]

def printGyro():
    print(getGyro())

#def raspi(c):
#    return input(f"{c}:")



def moveWithGyro(velocity:int, angle:int, duration:int, ST = motor.HOLD):
    utime.sleep_ms(30)
    motor_pair.stop(motor_pair.PAIR_1, stop=ST)
    start_time = utime.ticks_ms()
    while utime.ticks_diff(utime.ticks_ms(), start_time) < duration:
        adj = int(angle-getGyro())
        motor_pair.move_tank(motor_pair.PAIR_1, velocity + adj, velocity - adj)


    motor_pair.stop(motor_pair.PAIR_1,stop=ST)
    utime.sleep_ms(30)

def twoWheelTurn(angle:int):
    motor_pair.stop(motor_pair.PAIR_1,stop=motor.BRAKE)
    utime.sleep_ms(100)
    init_gyro = getGyro()
    oran_ti1 = -1*int((angle-init_gyro) * 4/11)
    oran_ti2 = -1*int((angle-init_gyro) * 3/11)
    oran_ti3 = -1*int(2/11 * (angle-init_gyro))
    if angle>init_gyro:
        while angle>= getGyro():
            if 1/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 4/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti1, oran_ti1)
            elif 5/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti2, oran_ti2)
            else:
                motor_pair.move_tank(motor_pair.PAIR_1, 140, -1*140)

        motor_pair.stop(motor_pair.PAIR_1,stop=motor.BRAKE)
        return
    else:
        while angle <= getGyro():
            if 1/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 4/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 5/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            else:
                motor_pair.move_tank(motor_pair.PAIR_1, -1*140, 140)

        motor_pair.stop(motor_pair.PAIR_1,stop=motor.BRAKE)
        return

def gyroRun(velocity:int, angle:int):
    adj = int(angle-getGyro())
    motor_pair.move_tank(motor_pair.PAIR_1, velocity + adj, velocity - adj)

def fastfastTurn(angle:int, turnDir="f"):
    # motor.run(port.A, 1000) positive
    motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)
    utime.sleep_ms(30)
    init_gyro = getGyro()
    if turnDir == "f" or turnDir=="F":
        mot1=SOL_TEKER # sol motor
        mot2=SAG_TEKER # sag motor
    else:
        mot1=SAG_TEKER # sag motor
        mot2=SOL_TEKER # sol motor
    #angle<init_gyro
    oran_ti1 = -1*int((angle-init_gyro) * 9/10)
    oran_ti2 = -1*int((angle-init_gyro) * 7/10)
    oran_ti3 = -1*int(5/10 * (angle-init_gyro))

    if angle>init_gyro: #angle>0
        while angle >= getGyro():
            if 1/7 * angle > getGyro():
                motor.run(mot1, oran_ti3)
            elif 4/7 * angle > getGyro():
                motor.run(mot1, oran_ti1)
            elif 5/7 * angle > getGyro():
                motor.run(mot1, oran_ti2)
            else:
                motor.run(mot1, -350)

        motor.stop(mot1, stop=motor.HOLD)
    else:
        while angle <= getGyro():#angle+init_gyro
            if 1/7 * angle < getGyro():
                motor.run(mot2, oran_ti3)
            elif 4/7 * angle < getGyro():
                motor.run(mot2, oran_ti1)
            elif 5/7 * angle < getGyro():
                motor.run(mot2, oran_ti2)
            else:
                motor.run(mot2, 350)

        motor.stop(mot2, stop=motor.HOLD)

    motor_pair.stop(motor_pair.PAIR_1, stop=motor.HOLD)
    utime.sleep_ms(80)

def twoWheelSlow(angle):
    motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)
    utime.sleep_ms(100)
    init_gyro = getGyro()
    oran_ti1 = -1*int((angle-init_gyro) * 6/22)
    oran_ti2 = -1*int((angle-init_gyro) * 4/22)
    oran_ti3 = -1*int(3/22 * (angle-init_gyro))
    if angle>init_gyro:
        while angle>= getGyro():
            if 1/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 4/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti1, oran_ti1)
            elif 5/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti2, oran_ti2)
            else:
                motor_pair.move_tank(motor_pair.PAIR_1, 140, -1*140)

        motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)

    else:
        while angle <= getGyro():
            if 1/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 4/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 5/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            else:
                motor_pair.move_tank(motor_pair.PAIR_1, -1*140, 140)

        motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)

    utime.sleep_ms(50)

def gyroTurn(angle:int, spid="f",turnDir="f", ST=motor.HOLD):
    # motor.run(port.A, 1000) positive
    #motor_pair.stop(motor_pair.PAIR_1,stop=ST)
    utime.sleep_ms(30)
    init_gyro = getGyro()
    if turnDir == "f" or turnDir=="F":
        mot1=SOL_TEKER # sol motor
        mot2=SAG_TEKER # sag motor
    else:
        mot1=SAG_TEKER # sag motor
        mot2=SOL_TEKER # sol motor
    if spid=="s" or spid=="S":
        #angle<init_gyro
        oran_ti1 = -1*int((angle-init_gyro)* 8/11)
        oran_ti2 = -1*int((angle-init_gyro) * 6/11)
        oran_ti3 = -1*int(4/11 * (angle-init_gyro))

    else:
        #angle<init_gyro
        oran_ti1 = -1*int((angle-init_gyro) * 4/5)
        oran_ti2 = -1*int((angle-init_gyro) * 3/5)
        oran_ti3 = -1*int(2/5 * (angle-init_gyro))
    if angle>init_gyro: #angle>0
        while angle >= getGyro(): # angle+init_gyro
            if 1/7 * angle > getGyro():
                motor.run(mot1, oran_ti3)
            elif 4/7 * angle > getGyro():
                motor.run(mot1, oran_ti1)
            elif 5/7 * angle > getGyro():
                motor.run(mot1, oran_ti2)
            else:
                motor.run(mot1, -280)

        motor.stop(mot1, stop=motor.HOLD)
    else:
        while angle <= getGyro():

            if 1/7 * angle < getGyro():
                motor.run(mot2, oran_ti3)
            elif 4/7 * angle < getGyro():
                motor.run(mot2, oran_ti1)
            elif 5/7 * angle < getGyro():
                motor.run(mot2, oran_ti2)
            else:
                motor.run(mot2, 280)

        motor.stop(mot2, stop=motor.HOLD)
    motor_pair.stop(motor_pair.PAIR_1, stop=motor.HOLD)
    utime.sleep_ms(140)

def checkColor(minimum:int, maximum:int):
    # range true döner. 90 siyahsa ve siyah görene kadar git ise 200 üstü örneğin
    W = (color_sensor.rgbi(RENK)[0] + color_sensor.rgbi(RENK)[1] + color_sensor.rgbi(RENK)[2])/3
    if W > minimum and W < maximum:
        return True
    else:
        return False


class DifferentialArms():
    ARM1 = 1 # Arm with no load
    ARM2 = 2 # Arm with load
    OPEN = 0

    def __init__(self, port, one_rotation_angle=64, close_direction=1,speed=500,start_position=0):
        """
        port: motor port
        one_rotation_angle: the required motor rotation for one arm to move
        start: starting position of the arms
                0: Both arms open
                ARM1: ARM1 is closed
                ARM2: ARM2 is cloesed (means ARM1 is also closed)
        """

        self._port = port
        self._one_rotation_angle = one_rotation_angle
        self.close_direction = close_direction
        self.speed=speed
        start_angle = int((2.6 if start_position==2 else 1 if start_position==1 else 0)*one_rotation_angle*close_direction)
        motor.reset_relative_position(self._port,start_angle)

    async def reset_everything(self, port=DERIVATIVE, one_rotation_angle=64, close_direction=1,speed=500,start_position=2):
        self._port = port
        self._one_rotation_angle = one_rotation_angle
        self.close_direction = close_direction
        self.speed=speed
        start_angle = int((2.6 if start_position==2 else 1 if start_position==1 else 0)*one_rotation_angle*close_direction)
        motor.reset_relative_position(self._port,start_angle)

    async def _moveArm(self,n,direction,speed):
        await motor.run_to_relative_position(self._port, int(self._one_rotation_angle * n * direction), speed)

    async def set_closed_arms(self, arm, speed=500):
        if arm==self.ARM1:
            await self._moveArm(1,self.close_direction,speed)

        elif arm==self.ARM2:
            await self._moveArm(2.6,self.close_direction,speed)

        elif arm==0:
            await self._moveArm(0,self.close_direction,speed)
        # await motor.run_to_relative_position(self._port,n*self._one_rotation_angle, 400)

    async def set_partial_closure(self, n, both_arms=True,speed=500):
        await diff_arms._moveArm(n*(2.6 if both_arms else 1),self.close_direction,speed=speed)

diff_arms = DifferentialArms(DERIVATIVE, close_direction=1,start_position=0)



def printColor():
    while(True):
        print((color_sensor.rgbi(RENK)[0] + color_sensor.rgbi(RENK)[1] + color_sensor.rgbi(RENK)[2])/3)
        utime.sleep_ms(800)

def go180(velocity:int, duration:int, ST = motor.HOLD):
    utime.sleep_ms(40)
    motor_pair.stop(motor_pair.PAIR_1, stop=ST)
    start_time = utime.ticks_ms()
    while utime.ticks_diff(utime.ticks_ms(), start_time) < duration:
        if getGyro() == 1800 or getGyro() == -1800:
            motor_pair.move_tank(motor_pair.PAIR_1, velocity, velocity)
        elif getGyro() > -1800 and getGyro() > 0:
            motor_pair.move_tank(motor_pair.PAIR_1, velocity + 30, velocity - 30)
        else:
            motor_pair.move_tank(motor_pair.PAIR_1, velocity - 30, velocity + 30)

    motor_pair.stop(motor_pair.PAIR_1,stop=ST)
    utime.sleep_ms(30)

def hizlann(velocity:int, angle:int, duration:int, katsayi:int, ST = motor.HOLD):
    utime.sleep_ms(20)
    motor_pair.stop(motor_pair.PAIR_1, stop=ST)
    start_time = utime.ticks_ms()
    init_velocity = 0
    while utime.ticks_diff(utime.ticks_ms(), start_time) < duration:
        adj = int(angle-getGyro())
        if abs(velocity) <= init_velocity:
            motor_pair.move_tank(motor_pair.PAIR_1, velocity + adj, velocity - adj)
        else:
            init_velocity = init_velocity + katsayi/duration


    motor_pair.stop(motor_pair.PAIR_1,stop=ST)
    utime.sleep_ms(30)


raspi = Raspi()
servo = raspi.register_device("servo", "kerem", "14","0","180","0.00095","0.0028","10")

kareRenk = input(";raspi_functions.image_job();\n").strip()
kareRenk = input(";raspi_functions.image_job();\n").strip()
kareRenk = input(";raspi_functions.image_job();\n").strip()

print(kareRenk)
# pozitif kolu aşağı çeker
async def main():
    #kareRenk = "y"
    motion_sensor.reset_yaw(0)
    motion_sensor.set_yaw_face(motion_sensor.TOP)
    motor_pair.pair(motor_pair.PAIR_1,SAG_TEKER,SOL_TEKER)

    utime.sleep_ms(2000)
    print(kareRenk)
    print(kareRenk)
    print(kareRenk)

    #kareRenk = "r"


    if kareRenk == "r" or kareRenk == "R":
        gyroTurn(510, "f", "b")
        moveWithGyro(-680, 510, 685)
        utime.sleep_ms(150)
        gyroTurn(-900, "s", "f")
        await motor.run_for_time(KALDIRAC, 520, 580, stop=motor.HOLD)
        motor.stop(KALDIRAC, stop=motor.BRAKE)
        gyroTurn(0, "f", "f")
        moveWithGyro(-540, 0, 340)
        while(checkColor(0, 470)):
            gyroRun(-380, 0)
        motor_pair.stop(motor_pair.PAIR_1)
        moveWithGyro(375, 0, 470)
        twoWheelTurn(900)

        #hizlann(-945, 910, 2070, 445)
        hizlann(-985, 910, 2160, 445)
        utime.sleep_ms(260)
        motor_pair.stop(motor_pair.PAIR_1, stop=motor.HOLD)
        utime.sleep_ms(150)

        await motor.run_for_time(KALDIRAC, 400, -600)
        moveWithGyro(950, 910, 1100)
        gyroTurn(0, "f", "f")
        moveWithGyro(-480, 0, 390)
        await motor.run_for_time(KALDIRAC, 450, 720)
        moveWithGyro(450, 0, 300)
        await motor.run_for_time(KALDIRAC, 450, -620)
        moveWithGyro(-360, 0, 220)

        twoWheelSlow(-890)
        moveWithGyro(-650, -900, 500, motor.COAST)
        moveWithGyro(-830, -900, 650, motor.COAST)
        moveWithGyro(-450, -900, 600, motor.COAST)
        utime.sleep_ms(600)


        # gyro sifirla
        motion_sensor.reset_yaw(0)
        motion_sensor.set_yaw_face(motion_sensor.TOP)

        #moveWithGyro(380, 0, 260)
        while(checkColor(0, 470)):
            gyroRun(300, 0)
        motor_pair.stop(motor_pair.PAIR_1, stop=motor.BRAKE)
        moveWithGyro(410, 0, 510)
        twoWheelSlow(-900)
        moveWithGyro(370, -900, 540)
    elif kareRenk == "y":
        gyroTurn(500, "f", "b")
        moveWithGyro(-980, 500, 1020)
        gyroTurn(-900, "s", "f")
        moveWithGyro(-630, -900, 510)
        gyroTurn(-1770, "f", "f")
        await motor.run_for_time(KALDIRAC, 520, 580, stop=motor.HOLD)
        motor.stop(KALDIRAC, stop=motor.BRAKE)
        await motor.run_for_time(SAG_TEKER, 350, 550)
        twoWheelTurn(20)
        moveWithGyro(-720, 0, 450)
        while(checkColor(0, 470)):
            gyroRun(-380, 0)
        motor_pair.stop(motor_pair.PAIR_1)
        moveWithGyro(368, 0, 460)
        twoWheelTurn(890)

        #hizlann(-945, 910, 2070, 445)
        hizlann(-960, 900, 2060, 445)

        utime.sleep_ms(260)
        motor_pair.stop(motor_pair.PAIR_1, stop=motor.HOLD)
        utime.sleep_ms(150)

        await motor.run_for_time(KALDIRAC, 400, -600)
        moveWithGyro(950, 910, 1100)
        gyroTurn(0, "f", "f")
        moveWithGyro(-480, 0, 390)
        await motor.run_for_time(KALDIRAC, 450, 720)
        moveWithGyro(450, 0, 300)
        await motor.run_for_time(KALDIRAC, 450, -620)
        moveWithGyro(-360, 0, 220)

        twoWheelSlow(-890)
        moveWithGyro(-650, -900, 500, motor.COAST)
        moveWithGyro(-830, -900, 650, motor.COAST)
        moveWithGyro(-450, -900, 600, motor.COAST)
        utime.sleep_ms(600)


        # gyro sifirla
        motion_sensor.reset_yaw(0)
        motion_sensor.set_yaw_face(motion_sensor.TOP)

        #moveWithGyro(380, 0, 260)
        while(checkColor(0, 470)):
            gyroRun(300, 0)
        motor_pair.stop(motor_pair.PAIR_1, stop=motor.BRAKE)
        moveWithGyro(410, 0, 510)
        twoWheelSlow(-900)
        moveWithGyro(370, -900, 540)
    else:
        hizlann(-900, 0, 1200, 500)
        await motor.run_for_time(KALDIRAC, 520, 580, stop=motor.HOLD)
        motor.stop(KALDIRAC, stop=motor.BRAKE)
        #motor.run(port.E, 250)
        while(checkColor(0, 470)):
            gyroRun(-380, 0)
        motor_pair.stop(motor_pair.PAIR_1)
        moveWithGyro(380, 0, 460)
        twoWheelTurn(900)

        #hizlann(-930, 905, 2000, 450)
        hizlann(-950, 905, 2100, 445)
        utime.sleep_ms(260)
        motor_pair.stop(motor_pair.PAIR_1, stop=motor.HOLD)
        utime.sleep_ms(150)

        await motor.run_for_time(KALDIRAC, 400, -600)
        moveWithGyro(950, 910, 1100)
        gyroTurn(0, "f", "f")
        moveWithGyro(-480, 0, 390)
        await motor.run_for_time(KALDIRAC, 450, 720)
        moveWithGyro(450, 0, 300)
        await motor.run_for_time(KALDIRAC, 450, -620)
        moveWithGyro(-360, 0, 220)

        twoWheelSlow(-890)
        moveWithGyro(-650, -900, 500, motor.COAST)
        moveWithGyro(-830, -900, 650, motor.COAST)
        moveWithGyro(-450, -900, 600, motor.COAST)
        utime.sleep_ms(600)


        # gyro sifirla
        motion_sensor.reset_yaw(0)
        motion_sensor.set_yaw_face(motion_sensor.TOP)

        #moveWithGyro(380, 0, 260)
        while(checkColor(0, 470)):
            gyroRun(300, 0)
        motor_pair.stop(motor_pair.PAIR_1, stop=motor.BRAKE)
        moveWithGyro(410, 0, 510)
        twoWheelSlow(-900)
        moveWithGyro(370, -900, 540)
    # küpleri kap ilk
    await diff_arms.set_partial_closure(0.9)

    moveWithGyro(-420, -900, 450)
    utime.sleep_ms(60)
    moveWithGyro(420, -900, 440)

    await diff_arms.set_partial_closure(-0.4, speed=-500)
    moveWithGyro(540, -900, 280, motor.COAST)
    moveWithGyro(360, -900, 280)

    # kap ikinci ilk
    await diff_arms.set_partial_closure(0.9)

    motor.run(DERIVATIVE, 200)
    # duvar sifirla
    moveWithGyro(-640, -900, 830)
    gyroTurn(0, "f", "b")

    motor.stop(DERIVATIVE)
    motor.run(DERIVATIVE, 350)
    moveWithGyro(-650, 0, 380, motor.COAST)
    moveWithGyro(-600, 0, 380, motor.COAST)
    moveWithGyro(-350, 0, 380)
    utime.sleep_ms(100)
    motor.stop(DERIVATIVE)
    while(checkColor(0, 470)):
        gyroRun(300, 0)
    motor_pair.stop(motor_pair.PAIR_1, stop=motor.COAST)
    #bas
    moveWithGyro(940, 0, 1600)

    gyroTurn(-900, "f", "b")
    motor.run(DERIVATIVE, 200)
    twoWheelSlow(900)
    motor_pair.stop(motor_pair.PAIR_1, stop=motor.HOLD)
    motor.stop(DERIVATIVE)
    utime.sleep_ms(100)
    motor.run(DERIVATIVE, 200)
    utime.sleep_ms(30)
    moveWithGyro(-400, 900, 520, motor.COAST)
    moveWithGyro(-580, 900, 700, motor.COAST)
    moveWithGyro(-360, 900, 500, motor.COAST)
    motor.stop(DERIVATIVE)
    utime.sleep_ms(500)
    motion_sensor.reset_yaw(0)
    motion_sensor.set_yaw_face(motion_sensor.TOP)


    #moveWithGyro(350, 0, 300)

    gyroTurn(-900, "s", "b")
    utime.sleep_ms(20)

    moveWithGyro(-206, -900, 228)
    utime.sleep_ms(100)
    # birak
    await diff_arms.set_partial_closure(-0.8, speed=-500)
    utime.sleep_ms(20)
    moveWithGyro(-440, -900, 445)

    

    twoWheelTurn(0)
    moveWithGyro(-600, 0, 280, motor.COAST)
    moveWithGyro(-420, 0, 250)
    utime.sleep_ms(350)
    servo.set_angle(77)
    servo.set_angle(77)
    servo.set_angle(77)
    utime.sleep_ms(250)
    moveWithGyro(620, 0, 450)
    utime.sleep_ms(200)
    moveWithGyro(-550, 0, 450)
    servo.set_angle(0)
    servo.set_angle(0)
    servo.set_angle(0)
    servo.set_angle(0)
    utime.sleep_ms(250)
    moveWithGyro(1020, 0, 1650)



    await diff_arms.set_closed_arms(1, 500)
    twoWheelTurn(-900)
    moveWithGyro(1000, -900, 680)
    fastfastTurn(-1090, "b")
    gyroTurn(-900, "f", "b")
    await diff_arms.set_closed_arms(0, -500)

    moveWithGyro(940, -900, 480)
    while(checkColor(700, 1500)):
        gyroRun(300, -900)
    motor_pair.stop(motor_pair.PAIR_1)

    moveWithGyro(950, -900, 950)
    gyroTurn(0, "s", "f")
    moveWithGyro(-880, 0, 660)
    await motor.run_for_time(KALDIRAC, 420, 650)
    # bayrak çek
    moveWithGyro(450, 0, 700)
    await motor.run_for_time(KALDIRAC, 400, -600)
    gyroTurn(-1770, "s", "b")
    go180(-600, 350, motor.COAST)
    go180(-750, 600, motor.COAST)
    go180(-600, 380, motor.COAST)
    go180(-430, 500, motor.COAST)
    utime.sleep_ms(300)
    motion_sensor.reset_yaw(0)
    motion_sensor.set_yaw_face(motion_sensor.TOP)
    # sifirla
    utime.sleep_ms(100)
    moveWithGyro(480, 0, 290)

    while(checkColor(0, 460)):
        gyroRun(350, 0)
    motor_pair.stop(motor_pair.PAIR_1)
    moveWithGyro(530, 0, 730)
    gyroTurn(-900, "s", "f")

    moveWithGyro(-720, -900, 1030)
    await motor.run_for_time(KALDIRAC, 480, 650)
    motor.run(KALDIRAC, 50)
    utime.sleep_ms(200)
    moveWithGyro(760, -900, 820)

    twoWheelTurn(-1760)
    go180(-910, 1170)
    motor.stop(KALDIRAC)
    motor.run_for_time(SOL_TEKER, 350, -650)
    utime.sleep_ms(200)
    gyroTurn(-445, "f", "f")

    moveWithGyro(-550, -460, 320)
    await motor.run_for_time(KALDIRAC, 400, -600)
    moveWithGyro(480, -460, 350)
    await motor.run_for_time(KALDIRAC, 450, 620)

    moveWithGyro(600, -460, 390)
    await diff_arms.set_partial_closure(0.8)
    moveWithGyro(-550, -460, 300)



    fastfastTurn(-280, "b")
    moveWithGyro(730, -280, 780)
    gyroTurn(-900, "s", "b")
    moveWithGyro(-500, -900, 540)
    await diff_arms.set_partial_closure(-0.4)
    moveWithGyro(530, -900, 500)
    utime.sleep_ms(100)
    moveWithGyro(-650, -900, 500)
    gyroTurn(500, "s" ,"f")
    twoWheelSlow(-1360)
    moveWithGyro(-750, -1360, 560)



runloop.run(main())
print(kareRenk)
