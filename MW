import motor
import motor_pair
import runloop
from hub import motion_sensor, port
import utime
import color_sensor
import distance_sensor


def getGyro():
    return -1*motion_sensor.tilt_angles()[0]

def printGyro():
    print(getGyro())

#def raspi(c):
#    return input(f"{c}:")



def moveWithGyro(velocity:int, angle:int, duration:int, ST = motor.HOLD):
    utime.sleep_ms(40)
    motor_pair.stop(motor_pair.PAIR_1, stop=ST)
    start_time = utime.ticks_ms()
    while utime.ticks_diff(utime.ticks_ms(), start_time) < duration:
        adj = int(angle-getGyro())
        motor_pair.move_tank(motor_pair.PAIR_1, velocity + adj, velocity - adj)


    motor_pair.stop(motor_pair.PAIR_1,stop=ST)
    utime.sleep_ms(30)

def twoWheelTurn(angle:int):
    motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)
    utime.sleep_ms(100)
    init_gyro = getGyro()
    oran_ti1 = -1*int((angle-init_gyro) * 4/11)
    oran_ti2 = -1*int((angle-init_gyro) * 3/11)
    oran_ti3 = -1*int(2/11 * (angle-init_gyro))
    if angle>init_gyro:
        while angle>= getGyro():
            if 1/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 4/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti1, oran_ti1)
            elif 5/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti2, oran_ti2)
            else:
                motor_pair.move_tank(motor_pair.PAIR_1, 140, -1*140)

        motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)
        return
    else:
        while angle <= getGyro():
            if 1/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 4/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 5/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            else:
                motor_pair.move_tank(motor_pair.PAIR_1, -1*140, 140)

        motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)
        return

def gyroRun(velocity:int, angle:int):
    adj = int(angle-getGyro())
    motor_pair.move_tank(motor_pair.PAIR_1, velocity + adj, velocity - adj)

def fastfastTurn(angle:int, turnDir="f"):
    # motor.run(port.A, 1000) positive
    motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)
    utime.sleep_ms(30)
    init_gyro = getGyro()
    if turnDir == "f" or turnDir=="F":
        mot1=port.C # sol motor
        mot2=port.A # sag motor
    else:
        mot1=port.A # sag motor
        mot2=port.C # sol motor
    #angle<init_gyro
    oran_ti1 = -1*int((angle-init_gyro) * 9/10)
    oran_ti2 = -1*int((angle-init_gyro) * 7/10)
    oran_ti3 = -1*int(5/10 * (angle-init_gyro))

    if angle>init_gyro: #angle>0
        while angle >= getGyro():
            if 1/7 * angle > getGyro():
                motor.run(mot1, oran_ti3)
            elif 4/7 * angle > getGyro():
                motor.run(mot1, oran_ti1)
            elif 5/7 * angle > getGyro():
                motor.run(mot1, oran_ti2)
            else:
                motor.run(mot1, -350)

        motor.stop(mot1, stop=motor.HOLD)
    else:
        while angle <= getGyro():#angle+init_gyro
            if 1/7 * angle < getGyro():
                motor.run(mot2, oran_ti3)
            elif 4/7 * angle < getGyro():
                motor.run(mot2, oran_ti1)
            elif 5/7 * angle < getGyro():
                motor.run(mot2, oran_ti2)
            else:
                motor.run(mot2, 350)

        motor.stop(mot2, stop=motor.HOLD)

    motor_pair.stop(motor_pair.PAIR_1, stop=motor.HOLD)
    utime.sleep_ms(80)

def twoWheelSlow(angle):
    motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)
    utime.sleep_ms(100)
    init_gyro = getGyro()
    oran_ti1 = -1*int((angle-init_gyro) * 6/22)
    oran_ti2 = -1*int((angle-init_gyro) * 4/22)
    oran_ti3 = -1*int(3/22 * (angle-init_gyro))
    if angle>init_gyro:
        while angle>= getGyro():
            if 1/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 4/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti1, oran_ti1)
            elif 5/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti2, oran_ti2)
            else:
                motor_pair.move_tank(motor_pair.PAIR_1, 140, -1*140)

        motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)

    else:
        while angle <= getGyro():
            if 1/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 4/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 5/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            else:
                motor_pair.move_tank(motor_pair.PAIR_1, -1*140, 140)

        motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)

    utime.sleep_ms(50)

def gyroTurn(angle:int, spid="f",turnDir="f", ST=motor.HOLD):
    # motor.run(port.A, 1000) positive
    #motor_pair.stop(motor_pair.PAIR_1,stop=ST)
    utime.sleep_ms(30)
    init_gyro = getGyro()
    if turnDir == "f" or turnDir=="F":
        mot1=port.C # sol motor
        mot2=port.A # sag motor
    else:
        mot1=port.A # sag motor
        mot2=port.C # sol motor
    if spid=="s" or spid=="S":
        #angle<init_gyro
        oran_ti1 = -1*int((angle-init_gyro)* 8/11)
        oran_ti2 = -1*int((angle-init_gyro) * 6/11)
        oran_ti3 = -1*int(4/11 * (angle-init_gyro))

    else:
        #angle<init_gyro
        oran_ti1 = -1*int((angle-init_gyro) * 4/5)
        oran_ti2 = -1*int((angle-init_gyro) * 3/5)
        oran_ti3 = -1*int(2/5 * (angle-init_gyro))
    if angle>init_gyro: #angle>0
        while angle >= getGyro(): # angle+init_gyro
            if 1/7 * angle > getGyro():
                motor.run(mot1, oran_ti3)
            elif 4/7 * angle > getGyro():
                motor.run(mot1, oran_ti1)
            elif 5/7 * angle > getGyro():
                motor.run(mot1, oran_ti2)
            else:
                motor.run(mot1, -280)

        motor.stop(mot1, stop=motor.HOLD)
    else:
        while angle <= getGyro():

            if 1/7 * angle < getGyro():
                motor.run(mot2, oran_ti3)
            elif 4/7 * angle < getGyro():
                motor.run(mot2, oran_ti1)
            elif 5/7 * angle < getGyro():
                motor.run(mot2, oran_ti2)
            else:
                motor.run(mot2, 280)

        motor.stop(mot2, stop=motor.HOLD)
    motor_pair.stop(motor_pair.PAIR_1, stop=motor.HOLD)
    utime.sleep_ms(140)

def checkColor(minimum:int, maximum:int):
    # range true döner. 90 siyahsa ve siyah görene kadar git ise 200 üstü örneğin
    W = (color_sensor.rgbi(port.D)[0] + color_sensor.rgbi(port.D)[1] + color_sensor.rgbi(port.D)[2])/3
    if W > minimum and W < maximum:
        return True
    else:
        return False


class DifferentialArms():
    ARM1 = 1 # Arm with no load
    ARM2 = 2 # Arm with load
    OPEN = 0

    def __init__(self, port, one_rotation_angle=64, close_direction=1,speed=500,start_position=0):
        """
        port: motor port
        one_rotation_angle: the required motor rotation for one arm to move
        start: starting position of the arms
                0: Both arms open
                ARM1: ARM1 is closed
                ARM2: ARM2 is cloesed (means ARM1 is also closed)
        """

        self._port = port
        self._one_rotation_angle = one_rotation_angle
        self.close_direction = close_direction
        self.speed=speed
        start_angle = int((2.6 if start_position==2 else 1 if start_position==1 else 0)*one_rotation_angle*close_direction)
        print(start_angle)
        motor.reset_relative_position(self._port,start_angle)

    async def reset_everything(self, port=port.B, one_rotation_angle=64, close_direction=1,speed=500,start_position=2):
        self._port = port
        self._one_rotation_angle = one_rotation_angle
        self.close_direction = close_direction
        self.speed=speed
        start_angle = int((2.6 if start_position==2 else 1 if start_position==1 else 0)*one_rotation_angle*close_direction)
        print(start_angle)
        motor.reset_relative_position(self._port,start_angle)

    async def _moveArm(self,n,direction,speed):
        await motor.run_to_relative_position(self._port, int(self._one_rotation_angle * n * direction), speed)

    async def set_closed_arms(self, arm, speed=500):
        if arm==self.ARM1:
            await self._moveArm(1,self.close_direction,speed)

        elif arm==self.ARM2:
            await self._moveArm(2.6,self.close_direction,speed)

        elif arm==0:
            await self._moveArm(0,self.close_direction,speed)
        # await motor.run_to_relative_position(self._port,n*self._one_rotation_angle, 400)

    async def set_partial_closure(self, n, both_arms=True,speed=500):
        await diff_arms._moveArm(n*(2.6 if both_arms else 1),self.close_direction,speed=speed)

diff_arms = DifferentialArms(port.B,close_direction=1,start_position=0)



def printColor():
    while(True):
        print((color_sensor.rgbi(port.D)[0] + color_sensor.rgbi(port.D)[1] + color_sensor.rgbi(port.D)[2])/3)
        utime.sleep_ms(800)

def go180(velocity:int, duration:int, ST = motor.HOLD):
    utime.sleep_ms(40)
    motor_pair.stop(motor_pair.PAIR_1, stop=ST)
    start_time = utime.ticks_ms()
    while utime.ticks_diff(utime.ticks_ms(), start_time) < duration:
        if getGyro() == 1800 or getGyro() == -1800:
            motor_pair.move_tank(motor_pair.PAIR_1, velocity, velocity)
        elif getGyro() > -1800 and getGyro() > 0:
            motor_pair.move_tank(motor_pair.PAIR_1, velocity + 30, velocity - 30)
        else:
             motor_pair.move_tank(motor_pair.PAIR_1, velocity - 30, velocity + 30)

    motor_pair.stop(motor_pair.PAIR_1,stop=ST)
    utime.sleep_ms(30)



# pozitif kolu aşağı çeker
async def main():

    motion_sensor.reset_yaw(0)
    motion_sensor.set_yaw_face(motion_sensor.TOP)
    motor_pair.pair(motor_pair.PAIR_1,port.A,port.C)

    moveWithGyro(-560, 0, 320, motor.SMART_COAST)
    moveWithGyro(-770, 0, 550, motor.SMART_COAST)
    moveWithGyro(-600, 0, 290)
    await motor.run_for_time(port.E, 450, 680)
    #motor.run(port.E, 250)
    while(checkColor(0, 470)):
        gyroRun(-400, 0)
    motor_pair.stop(motor_pair.PAIR_1)
    moveWithGyro(310, 0, 330)
    twoWheelSlow(900)
    #motor.stop(port.E)
    moveWithGyro(-650, 910, 330, motor.COAST)
    moveWithGyro(-900, 910, 1100, motor.COAST)
    moveWithGyro(-700, 910, 610)

    await motor.run_for_time(port.E, 400, -600)
    moveWithGyro(880, 910, 1100)
    gyroTurn(0, "f", "f")
    moveWithGyro(-560, 0, 430)
    await motor.run_for_time(port.E, 450, 720)
    moveWithGyro(400, 0, 300)
    await motor.run_for_time(port.E, 400, -600)
    moveWithGyro(-400, 0, 300)
    twoWheelSlow(-900)
    moveWithGyro(-650, -910, 500, motor.COAST)
    moveWithGyro(-880, -910, 750, motor.COAST)
    moveWithGyro(-450, -910, 600, motor.COAST)
    utime.sleep_ms(600)

    # gyro sifirla
    motion_sensor.reset_yaw(0)
    motion_sensor.set_yaw_face(motion_sensor.TOP)

    moveWithGyro(450, 0, 320)
    while(checkColor(0, 470)):
        gyroRun(300, 0)
    motor_pair.stop(motor_pair.PAIR_1, stop=motor.BRAKE)
    moveWithGyro(360, 0, 270)
    twoWheelSlow(-900)
    moveWithGyro(390, -900, 480)

    # küpleri kap ilk
    await diff_arms.set_partial_closure(0.8)

    moveWithGyro(-420, -900, 450)
    utime.sleep_ms(60)
    moveWithGyro(420, -900, 440)

    await diff_arms.set_partial_closure(-0.4, speed=-500)
    moveWithGyro(550, -900, 300, motor.COAST)
    moveWithGyro(360, -900, 330)

    # kap ikinci ilk
    await diff_arms.set_partial_closure(0.8)

    motor.run(port.B, 200)
    # duvar sifirla
    moveWithGyro(-640, -900, 830)
    gyroTurn(0, "f", "b")
    motor.stop(port.B)
    motor.run(port.B, 350)
    moveWithGyro(-700, 0, 380, motor.COAST)
    moveWithGyro(-600, 0, 380, motor.COAST)
    moveWithGyro(-350, 0, 380)
    utime.sleep_ms(100)
    motor.stop(port.B)
    moveWithGyro(450, 0, 290)
    while(checkColor(0, 470)):
        gyroRun(300, 0)
    motor_pair.stop(motor_pair.PAIR_1, stop=motor.COAST)
    #bas
    moveWithGyro(1010, 0, 1420)

    gyroTurn(-900, "f", "b")
    twoWheelSlow(900)
    utime.sleep_ms(20)
    motor.run(port.B, 180)
    moveWithGyro(-800, 900, 500, motor.COAST)
    moveWithGyro(-640, 900, 360, motor.COAST)
    moveWithGyro(-360, 900, 350, motor.COAST)
    motor.stop(port.B)
    utime.sleep_ms(500)
    motion_sensor.reset_yaw(0)
    motion_sensor.set_yaw_face(motion_sensor.TOP)


    moveWithGyro(625, 0, 300)

    gyroTurn(-900, "s", "b")
    utime.sleep_ms(20)
    moveWithGyro(-220, -900, 240)
    utime.sleep_ms(100)
    # birak
    await diff_arms.set_partial_closure(-0.6, speed=-500)
    utime.sleep_ms(20)

    moveWithGyro(-350, -900, 680)
    utime.sleep_ms(20)
    gyroTurn(-200, "f", "b")
    moveWithGyro(-500, -200, 400)
    gyroTurn(240, "f", "b")
    moveWithGyro(520, 240, 310)
    gyroTurn(-30, "s", "f")
    moveWithGyro(-420, -30, 290)
    twoWheelTurn(20)
    await motor.run_for_time(port.E, 360, 440, stop=motor.HOLD)
    moveWithGyro(680, 30, 700)
    utime.sleep_ms(50)
    await motor.run_for_time(port.E, 400, -600)
    moveWithGyro(1010,0, 1140)
    await diff_arms.set_closed_arms(1, 500)
    twoWheelTurn(-900)
    moveWithGyro(950, -900, 650)
    fastfastTurn(-1040, "b")
    gyroTurn(-900, "f", "b")
    await diff_arms.set_closed_arms(0, -500)

    moveWithGyro(750, -900, 500)
    while(checkColor(700, 1500)):
        gyroRun(300, -900)
    motor_pair.stop(motor_pair.PAIR_1)

    moveWithGyro(900, -900, 900)
    gyroTurn(0, "s", "f")
    moveWithGyro(-900, 0, 750)
    await motor.run_for_time(port.E, 400, 600)
    # bayrak çek
    moveWithGyro(500, 0, 750)
    await motor.run_for_time(port.E, 400, -600)
    gyroTurn(-1770, "s", "b")
    go180(-600, 350, motor.COAST)
    go180(-750, 550, motor.COAST)
    go180(-600, 380, motor.COAST)
    go180(-430, 500, motor.COAST)
    utime.sleep_ms(300)
    motion_sensor.reset_yaw(0)
    motion_sensor.set_yaw_face(motion_sensor.TOP)   
    utime.sleep_ms(100)
    moveWithGyro(600, 0, 360)
    while(checkColor(0, 460)):
        gyroRun(350, 0)
    motor_pair.stop(motor_pair.PAIR_1)
    moveWithGyro(610, 0, 455)
    gyroTurn(-900, "s", "f")
    moveWithGyro(-720, -900, 1000)
    await motor.run_for_time(port.E, 480, 650)
    motor.run(port.E, 42)
    utime.sleep_ms(200)
    moveWithGyro(760, -900, 780)
    twoWheelTurn(-1770)
    go180(-920, 1220)
    motor.stop(port.E)
    await motor.run_for_time(port.C, 300, -600)
    gyroTurn(-460, "f", "f")
    moveWithGyro(-700, -460, 410)
    await motor.run_for_time(port.E, 400, -600)
    moveWithGyro(660, -460, 338)
    await motor.run_for_time(port.E, 450, 650)
    moveWithGyro(600, -460, 400)
    await diff_arms.set_partial_closure(0.8)
    moveWithGyro(-550, -460, 300)



    fastfastTurn(-280, "b")
    moveWithGyro(730, -280, 760)
    gyroTurn(-900, "s", "b")
    moveWithGyro(-640, -900, 500)
    await diff_arms.set_partial_closure(-0.4)
    moveWithGyro(640, -900, 500)
    utime.sleep_ms(100)
    moveWithGyro(-600, -900, 520)
    gyroTurn(500, "s" ,"f")
    twoWheelSlow(-1360)
    moveWithGyro(-620, -1360, 500)



runloop.run(main())
