import motor
import motor_pair
import runloop
from hub import motion_sensor, port
import utime
import color_sensor
import distance_sensor


def getGyro():
    return -1*motion_sensor.tilt_angles()[0]

def printGyro():
    print(getGyro())

#def raspi(c):
#    return input(f"{c}:")

def adamGibiDon(angle:int, turnDir="f"):
    init_gyro = getGyro()
    mot1 = None
    mot2 = None
    if turnDir == "f" or turnDir=="F":
        mot1=port.F # sol motor
        mot2=port.B # sag motor
    else:
        mot1=port.B # sag motor
        mot2=port.F # sol motor

    oran_ti1 = -1*int((angle-init_gyro) * 8/11)
    oran_ti2 = -1*int((angle-init_gyro) * 6/11)
    oran_ti3 = -1*int(4/11 * (angle-init_gyro))

    if angle>init_gyro: #angle>0
        while angle >= getGyro():
            if 1/7 * angle > getGyro():
                motor.run(mot1, oran_ti3)
            elif 2/7 * angle > getGyro():
                motor.run(mot1, oran_ti1)
            elif 4/7 * angle > getGyro():
                motor.run(mot1, oran_ti2)
            else:
                motor.run(mot1, -280)

        motor.stop(mot1, stop=motor.HOLD)
    else:
        while angle <= getGyro():#angle+init_gyro
            if 1/7 * angle < getGyro():
                motor.run(mot2, oran_ti3)
            elif 2/7 * angle < getGyro():
                motor.run(mot2, oran_ti1)
            elif 4/7 * angle < getGyro():
                motor.run(mot2, oran_ti2)
            else:
                motor.run(mot2, 280)

    motor_pair.stop(motor_pair.PAIR_1, stop=motor.HOLD)
    utime.sleep_ms(40)

def moveWithGyro(velocity:int, angle:int, duration:int, ST = motor.HOLD):
    utime.sleep_ms(40)
    motor_pair.stop(motor_pair.PAIR_1, stop=ST)
    start_time = utime.ticks_ms()
    while utime.ticks_diff(utime.ticks_ms(), start_time) < duration:
        adj = int(angle-getGyro())
        motor_pair.move_tank(motor_pair.PAIR_1, velocity + adj, velocity - adj)


    motor_pair.stop(motor_pair.PAIR_1,stop=ST)
    utime.sleep_ms(30)

def twoWheelTurn(angle:int):
    motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)
    utime.sleep_ms(100)
    init_gyro = getGyro()
    oran_ti1 = -1*int((angle-init_gyro) * 4/11)
    oran_ti2 = -1*int((angle-init_gyro) * 3/11)
    oran_ti3 = -1*int(2/11 * (angle-init_gyro))
    if angle>init_gyro:
        while angle>= getGyro():
            if 1/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 4/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti1, oran_ti1)
            elif 5/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti2, oran_ti2)
            else:
                motor_pair.move_tank(motor_pair.PAIR_1, 140, -1*140)

        motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)
        return
    else:
        while angle <= getGyro():
            if 1/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 4/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 5/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            else:
                motor_pair.move_tank(motor_pair.PAIR_1, -1*140, 140)

        motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)
        return

def gyroRun(velocity:int, angle:int):
    adj = int(angle-getGyro())
    motor_pair.move_tank(motor_pair.PAIR_1, velocity + adj, velocity - adj)

def fastfastTurn(angle:int, turnDir="f"):
    # motor.run(port.A, 1000) positive
    motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)
    utime.sleep_ms(30)
    init_gyro = getGyro()
    if turnDir == "f" or turnDir=="F":
        mot1=port.C # sol motor
        mot2=port.A # sag motor
    else:
        mot1=port.A # sag motor
        mot2=port.C # sol motor
    #angle<init_gyro
    oran_ti1 = -1*int((angle-init_gyro) * 9/10)
    oran_ti2 = -1*int((angle-init_gyro) * 7/10)
    oran_ti3 = -1*int(5/10 * (angle-init_gyro))

    if angle>init_gyro: #angle>0
        while angle >= getGyro():
            if 1/7 * angle > getGyro():
                motor.run(mot1, oran_ti3)
            elif 4/7 * angle > getGyro():
                motor.run(mot1, oran_ti1)
            elif 5/7 * angle > getGyro():
                motor.run(mot1, oran_ti2)
            else:
                motor.run(mot1, -350)

        motor.stop(mot1, stop=motor.HOLD)
    else:
        while angle <= getGyro():#angle+init_gyro
            if 1/7 * angle < getGyro():
                motor.run(mot2, oran_ti3)
            elif 4/7 * angle < getGyro():
                motor.run(mot2, oran_ti1)
            elif 5/7 * angle < getGyro():
                motor.run(mot2, oran_ti2)
            else:
                motor.run(mot2, 350)

        motor.stop(mot2, stop=motor.HOLD)

    motor_pair.stop(motor_pair.PAIR_1, stop=motor.HOLD)
    utime.sleep_ms(80)

def twoWheelSlow(angle):
    motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)
    utime.sleep_ms(100)
    init_gyro = getGyro()
    oran_ti1 = -1*int((angle-init_gyro) * 6/22)
    oran_ti2 = -1*int((angle-init_gyro) * 4/22)
    oran_ti3 = -1*int(3/22 * (angle-init_gyro))
    if angle>init_gyro:
        while angle>= getGyro():
            if 1/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 4/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti1, oran_ti1)
            elif 5/7 * angle > getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti2, oran_ti2)
            else:
                motor_pair.move_tank(motor_pair.PAIR_1, 140, -1*140)

        motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)

    else:
        while angle <= getGyro():
            if 1/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 4/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            elif 5/7 * angle < getGyro():
                motor_pair.move_tank(motor_pair.PAIR_1, -1*oran_ti3, oran_ti3)
            else:
                motor_pair.move_tank(motor_pair.PAIR_1, -1*140, 140)

        motor_pair.stop(motor_pair.PAIR_1,stop=motor.HOLD)

    utime.sleep_ms(50)

def gyroTurn(angle:int, spid="f",turnDir="f", ST=motor.HOLD):
    # motor.run(port.A, 1000) positive
    #motor_pair.stop(motor_pair.PAIR_1,stop=ST)
    utime.sleep_ms(30)
    init_gyro = getGyro()
    if turnDir == "f" or turnDir=="F":
        mot1=port.C # sol motor
        mot2=port.A # sag motor
    else:
        mot1=port.A # sag motor
        mot2=port.C # sol motor
    if spid=="s" or spid=="S":
        #angle<init_gyro
        oran_ti1 = -1*int((angle-init_gyro)* 8/11)
        oran_ti2 = -1*int((angle-init_gyro) * 6/11)
        oran_ti3 = -1*int(4/11 * (angle-init_gyro))

    else:
        #angle<init_gyro
        oran_ti1 = -1*int((angle-init_gyro) * 4/5)
        oran_ti2 = -1*int((angle-init_gyro) * 3/5)
        oran_ti3 = -1*int(2/5 * (angle-init_gyro))
    if angle>init_gyro: #angle>0
        while angle >= getGyro(): # angle+init_gyro
            if 1/7 * angle > getGyro():
                motor.run(mot1, oran_ti3)
            elif 4/7 * angle > getGyro():
                motor.run(mot1, oran_ti1)
            elif 5/7 * angle > getGyro():
                motor.run(mot1, oran_ti2)
            else:
                motor.run(mot1, -280)

        motor.stop(mot1, stop=motor.HOLD)
    else:
        while angle <= getGyro():

            if 1/7 * angle < getGyro():
                motor.run(mot2, oran_ti3)
            elif 4/7 * angle < getGyro():
                motor.run(mot2, oran_ti1)
            elif 5/7 * angle < getGyro():
                motor.run(mot2, oran_ti2)
            else:
                motor.run(mot2, 280)

        motor.stop(mot2, stop=motor.HOLD)
    motor_pair.stop(motor_pair.PAIR_1, stop=motor.HOLD)
    utime.sleep_ms(140)

def checkColor(minimum:int, maximum:int):
    # range true döner. 90 siyahsa ve siyah görene kadar git ise 200 üstü örneğin
    W = (color_sensor.rgbi(port.D)[0] + color_sensor.rgbi(port.D)[1] + color_sensor.rgbi(port.D)[2])/3
    if W > minimum and W < maximum:
        return True
    else:
        return False


class DifferentialArms():
    ARM1 = 1 # Arm with no load
    ARM2 = 2 # Arm with load
    OPEN = 0

    def __init__(self, port, one_rotation_angle=64, close_direction=-1,speed=400,start_position=2):
        """
        port: motor port
        one_rotation_angle: the required motor rotation for one arm to move
        start: starting position of the arms
                0: Both arms open
                ARM1: ARM1 is closed
                ARM2: ARM2 is cloesed (means ARM1 is also closed)
        """

        self._port = port
        self._one_rotation_angle = one_rotation_angle
        self.close_direction = close_direction
        self.speed=speed
        start_angle = int((2.6 if start_position==2 else 1 if start_position==1 else 0)*one_rotation_angle*close_direction)
        print(start_angle)
        motor.reset_relative_position(self._port,start_angle)

    async def reset_everything(self, port=port.B, one_rotation_angle=64, close_direction=-1,speed=400,start_position=2):
        self._port = port
        self._one_rotation_angle = one_rotation_angle
        self.close_direction = close_direction
        self.speed=speed
        start_angle = int((2.6 if start_position==2 else 1 if start_position==1 else 0)*one_rotation_angle*close_direction)
        print(start_angle)
        motor.reset_relative_position(self._port,start_angle)

    async def _moveArm(self,n,direction,speed):
        await motor.run_to_relative_position(self._port, int(self._one_rotation_angle * n * direction), speed)

    async def set_closed_arms(self, arm, speed=400):
        if arm==self.ARM1:
            await self._moveArm(1,self.close_direction,speed)

        elif arm==self.ARM2:
            await self._moveArm(2.6,self.close_direction,speed)

        elif arm==0:
            await self._moveArm(0,self.close_direction,speed)
        # await motor.run_to_relative_position(self._port,n*self._one_rotation_angle, 400)

    async def set_partial_closure(self, n, both_arms=True,speed=400):
        await diff_arms._moveArm(n*(2.6 if both_arms else 1),self.close_direction,speed=speed)

diff_arms = DifferentialArms(port.B,close_direction=1,start_position=2)



def printColor():
    while(True):
        print((color_sensor.rgbi(port.D)[0] + color_sensor.rgbi(port.D)[1] + color_sensor.rgbi(port.D)[2])/3)
        utime.sleep_ms(800)

# pozitif kolu aşağı çeker
async def main():
    motion_sensor.reset_yaw(0)
    motion_sensor.set_yaw_face(motion_sensor.TOP)

    motor_pair.pair(motor_pair.PAIR_1,port.A,port.C)

    #await motor.run_for_time(port.E, 300, 250)
    #await diff_arms.set_partial_closure(0.02)

    moveWithGyro(-560, 0, 340, motor.SMART_COAST)
    moveWithGyro(-770, 0, 550, motor.SMART_COAST)
    moveWithGyro(-600, 0, 300)
    await motor.run_for_time(port.E, 450, 680)
    motor.run(port.C, 400)
    while(checkColor(0, 470)):
        gyroRun(-400, 0)
    motor_pair.stop(motor_pair.PAIR_1)
    moveWithGyro(270, 0, 270)
    twoWheelSlow(900)
    motor.stop(port.C)
    moveWithGyro(-900, 910, 1680, motor.BRAKE)
    await motor.run_for_time(port.E, 400, -600)
    moveWithGyro(880, 910, 1100)
    gyroTurn(0, "f", "f")
    moveWithGyro(-560, 0, 430)
    await motor.run_for_time(port.E, 450, 720)
    moveWithGyro(400, 0, 300)
    await motor.run_for_time(port.E, 400, -600)
    moveWithGyro(-400, 0, 300)
    twoWheelSlow(-900)
    moveWithGyro(-650, -910, 500, motor.COAST)
    moveWithGyro(-880, -910, 750, motor.COAST)
    moveWithGyro(-450, -910, 600, motor.COAST)
    utime.sleep_ms(700)

    # gyro sifirla
    motion_sensor.reset_yaw(0)
    motion_sensor.set_yaw_face(motion_sensor.TOP)

    moveWithGyro(450, 0, 320)
    while(checkColor(0, 470)):
        gyroRun(300, 0)
    motor_pair.stop(motor_pair.PAIR_1, stop=motor.BRAKE)
    moveWithGyro(350, 0, 250)
    twoWheelSlow(-900)
    moveWithGyro(410, -900, 480)

    # küpleri kap ilk
    await diff_arms.reset_everything(close_direction=-1)
    await diff_arms.set_partial_closure(0.12)
    utime.sleep_ms(50)

    moveWithGyro(-420, -900, 450)
    utime.sleep_ms(60)
    moveWithGyro(420, -900, 440)

    await diff_arms.reset_everything(close_direction=1)
    await diff_arms.set_partial_closure(0.12)
    moveWithGyro(550, -900, 300, motor.COAST)
    moveWithGyro(360, -900, 330)

    # kap ikinci ilk
    await diff_arms.reset_everything(close_direction=-1)
    await diff_arms.set_partial_closure(0.18)

    motor.run(port.B, 150)
    # duvar sifirla
    moveWithGyro(-640, -900, 830)
    gyroTurn(0, "f", "b")
    moveWithGyro(-780, 0, 340, motor.COAST)
    moveWithGyro(-600, 0, 380, motor.COAST)
    moveWithGyro(-350, 0, 350)
    utime.sleep_ms(100)
    motor.stop(port.B)
    moveWithGyro(450, 0, 290)
    while(checkColor(0, 470)):
        gyroRun(300, 0)
    motor_pair.stop(motor_pair.PAIR_1, stop=motor.COAST)
    moveWithGyro(1010, 0, 1450)

    gyroTurn(-900, "f", "b")
    twoWheelSlow(900)
    utime.sleep_ms(20)
    motor.run(port.B, 180)
    moveWithGyro(-800, 900, 500, motor.COAST)
    moveWithGyro(-640, 900, 360, motor.COAST)
    moveWithGyro(-360, 900, 350, motor.COAST)
    motor.stop(port.B)
    utime.sleep_ms(500)
    motion_sensor.reset_yaw(0)
    motion_sensor.set_yaw_face(motion_sensor.TOP)


    moveWithGyro(625, 0, 300)

    gyroTurn(-900, "s", "b")
    utime.sleep_ms(20)
    moveWithGyro(-220, -900, 240)
    utime.sleep_ms(100)

    await diff_arms.reset_everything(close_direction=1)
    await diff_arms.set_partial_closure(0.15)
    utime.sleep_ms(20)

    moveWithGyro(-350, -900, 680)
    utime.sleep_ms(20)
    gyroTurn(-200, "f", "b")
    moveWithGyro(-500, -200, 400)
    gyroTurn(240, "f", "b")
    moveWithGyro(520, 240, 310)
    gyroTurn(-30, "s", "f")
    moveWithGyro(-420, -30, 290)
    twoWheelTurn(20)
    await motor.run_for_time(port.E, 370, 450, stop=motor.HOLD)
    moveWithGyro(670, 30, 660)
    utime.sleep_ms(50)
    moveWithGyro(-480, 0, 500)
    await motor.run_for_time(port.E, 300, -500)
    moveWithGyro(1010,0, 1380)
    twoWheelTurn(-900)
    moveWithGyro(950, -900, 650)
    fastfastTurn(-1150, "b")
    gyroTurn(-900, "f", "b")

runloop.run(main())
